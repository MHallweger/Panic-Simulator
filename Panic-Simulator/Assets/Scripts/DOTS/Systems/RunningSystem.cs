using Unity.Entities;
using Unity.Jobs;
using Unity.Mathematics;
using Unity.Collections;
using Unity.Transforms;
using Unity.Burst;
/// <summary>
/// System that reacts on panic spots, generated by mouse click.
/// </summary>
public class RunningSystem : JobComponentSystem
{
    EndSimulationEntityCommandBufferSystem m_EntityCommandBufferSystem; // For creating the commandBuffer

    /// <summary>
    /// Initialize The EndSimulationEntityCommandBufferSystem commandBufferSystem.
    /// </summary>
    protected override void OnCreate()
    {
        m_EntityCommandBufferSystem = World.GetOrCreateSystem<EndSimulationEntityCommandBufferSystem>();
    }

    [BurstCompile]
    public struct RunningJob : IJobForEachWithEntity<Translation, AgentComponent, MoveSpeedComponent>
    {
        public float deltaTime;
        public EntityCommandBuffer.Concurrent CommandBuffer; // instantiating and deleting of Entitys can only gets done on the main thread, save commands in buffer for main thread

        [NativeDisableParallelForRestriction]
        [DeallocateOnJobCompletion]
        public NativeArray<Random> RandomGenerator;

        [Unity.Collections.LowLevel.Unsafe.NativeSetThreadIndex]
        private int threadIndex;

        public void Execute(Entity entity, int index, ref Translation translation, ref AgentComponent agentComponent,
            [ReadOnly] ref MoveSpeedComponent moveSpeedComponent/*, [ReadOnly] ref BorderComponent borderComponent*/)
        {
            if (agentComponent.agentStatus == AgentStatus.Running && agentComponent.hasTarget)
            {
                float distance = math.distance(translation.Value, agentComponent.target);

                if (distance < .1f)
                {
                    if (agentComponent.foundFinalExitPoint)
                    {
                        // Agent is near to the target
                        agentComponent.agentStatus = AgentStatus.Moving;
                        agentComponent.hasTarget = false;
                        agentComponent.exitPointReached = true; // The CalculateNewRandomPositionSystem is able now to seperate the agents and allow the correct new random generated positions
                        agentComponent.marked = false;
                    }
                    else
                    {
                        agentComponent.hasTarget = false;
                        agentComponent.marked = false;
                    }
                }
                else
                {
                    // Agent has panic, need to run to the next closest escape spot
                    float3 direction = math.normalize(agentComponent.target - translation.Value);
                    translation.Value += direction * moveSpeedComponent.runningSpeed * deltaTime;
                }

                //var rnd = RandomGenerator[threadIndex - 1];
                //RandomGenerator[threadIndex - 1] = rnd; //This is necessary to update the state of the element inside the array.

                //float distance = math.distance(translation.Value, agentComponent.target);

                //if (distance < .1f)
                //{
                //    // Agent reached exit point
                //    if (!agentComponent.exitPointReached)
                //    {
                //        if (agentComponent.target.x > 180.0)
                //        {
                //            // Calculate new position with 90°
                //            float3 newRandomGeneratedSaveSpot = new float3(
                //                rnd.NextFloat(agentComponent.target.x + 10.0f, agentComponent.target.x + 30.0f),
                //                .5f,
                //                rnd.NextFloat(agentComponent.target.z - 20.0f, agentComponent.target.z + 20.0f));

                //            agentComponent.target = newRandomGeneratedSaveSpot;
                //            agentComponent.exitPointReached = true;
                //        }
                //        else
                //        {
                //            // Calculate new position with 90°
                //            float3 newRandomGeneratedSaveSpot = new float3(
                //                rnd.NextFloat(agentComponent.target.x - 10.0f, agentComponent.target.x - 30.0f),
                //                .5f,
                //                rnd.NextFloat(agentComponent.target.z - 20.0f, agentComponent.target.z + 20.0f));

                //            agentComponent.target = newRandomGeneratedSaveSpot;
                //            agentComponent.exitPointReached = true;
                //        }
                //    }
                //    else
                //    {
                //        // Idle
                //        translation.Value = agentComponent.target;
                //        agentComponent.hasTarget = false;
                //        agentComponent.agentStatus = AgentStatus.Idle;
                //    }
                //}
                //else
                //{
                //    // Agent has panic, need to run to the next closest escape spot
                //    float3 direction = math.normalize(agentComponent.target - translation.Value);
                //    translation.Value += direction * moveSpeedComponent.runningSpeed * deltaTime;
                //}
            }
        }
    }

    // No Burst because of the CommandBuffer
    public struct RemovePanicTagJob : IJobForEachWithEntity<AgentComponent>
    {
        public EntityCommandBuffer.Concurrent CommandBuffer; // instantiating and deleting of Entitys can only gets done on the main thread, save commands in buffer for main thread

        public void Execute(Entity entity, int index, ref AgentComponent agentComponent)
        {
            if (agentComponent.exitPointReached && agentComponent.foundFinalExitPoint && !agentComponent.marked)
            {
                if (!agentComponent.areaFinallyleaved) // prevent to run the following code over and over again -> saves main thread performance
                {
                    // Agent found an exit and has leaved the festival area
                    //CommandBuffer.RemoveComponent<PanicTag>(index, entity);
                    //CommandBuffer.AddComponent<EscapedTag>(index, entity);
                    agentComponent.areaFinallyleaved = true;
                }
            }
        }
    }

    Random Rnd = new Random(1);
    NativeArray<Random> RandomGenerator;
    /// <summary>
    /// Runs on main thread, 1 times per frame
    /// </summary>
    /// <param name="inputDeps"></param>
    /// <returns></returns>
    protected override JobHandle OnUpdate(JobHandle inputDeps)
    {
        RandomGenerator = new NativeArray<Random>(System.Environment.ProcessorCount, Allocator.TempJob);

        for (int i = 0; i < RandomGenerator.Length; i++)
        {
            RandomGenerator[i] = new Random((uint)Rnd.NextInt());
        }

        RunningJob runningJob = new RunningJob
        {
            deltaTime = UnityEngine.Time.deltaTime,
            RandomGenerator = RandomGenerator
        };

        JobHandle jobHandle = runningJob.Schedule(this, inputDeps);

        RemovePanicTagJob removePanicTagJob = new RemovePanicTagJob
        {
            CommandBuffer = m_EntityCommandBufferSystem.CreateCommandBuffer().ToConcurrent()
        };

        jobHandle = removePanicTagJob.Schedule(this, jobHandle);

        m_EntityCommandBufferSystem.AddJobHandleForProducer(jobHandle); // Execute the commandBuffer commands when spawnJob is finished

        return jobHandle;
    }
}
