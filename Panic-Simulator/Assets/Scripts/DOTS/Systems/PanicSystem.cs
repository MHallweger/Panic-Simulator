using Unity.Entities;
using Unity.Jobs;
using Unity.Mathematics;
using Unity.Collections;
using Unity.Transforms;
using Unity.Burst;
[UpdateBefore(typeof(MovingSystem))]
[UpdateBefore(typeof(ManagerSystem))]
[UpdateBefore(typeof(JumpingSystem))]
[UpdateBefore(typeof(CalculateNewRandomPositionSystem))]
/// <summary>
/// System that reacts on panic spots, generated by mouse click.
/// </summary>
public class PanicSystem : JobComponentSystem
{
    EndSimulationEntityCommandBufferSystem m_EntityCommandBufferSystem; // For creating the commandBuffer

    /// <summary>
    /// Initialize The EndSimulationEntityCommandBufferSystem commandBufferSystem.
    /// </summary>
    protected override void OnCreate()
    {
        m_EntityCommandBufferSystem = World.GetOrCreateSystem<EndSimulationEntityCommandBufferSystem>();
    }

    [BurstCompile]
    public struct PanicJob : IJobForEachWithEntity<Translation, AgentComponent>
    {
        public EntityCommandBuffer.Concurrent CommandBuffer; // instantiating and deleting of Entitys can only gets done on the main thread, save commands in buffer for main thread

        [DeallocateOnJobCompletion]
        [ReadOnly] public NativeArray<float3> exitsTranslations;

        public void Execute(Entity entity, int index, [ReadOnly] ref Translation translation, ref AgentComponent agentComponent)
        {
            float3 closestExitTarget = float3.zero;
            float3 agentPosition = translation.Value;

            for (int i = 0; i < exitsTranslations.Length; i++)
            {
                if (closestExitTarget.Equals(float3.zero))
                {
                    // No target
                    closestExitTarget = exitsTranslations[i];
                }
                else
                {
                    if (math.distance(agentPosition, exitsTranslations[i]) < math.distance(agentPosition, closestExitTarget))
                    {
                        closestExitTarget = exitsTranslations[i];
                    }
                }
            }
            agentComponent.target = closestExitTarget;
            agentComponent.agentStatus = AgentStatus.Running;
            agentComponent.hasTarget = true;
        }
    }
    NativeArray<Translation> exitsTranslations;
    NativeArray<float3> finalExitPositions;

    /// <summary>
    /// Runs on main thread, 1 times per frame
    /// </summary>
    /// <param name="inputDeps"></param>
    /// <returns></returns>
    protected override JobHandle OnUpdate(JobHandle inputDeps)
    {
        JobHandle jobHandle = new JobHandle();

        if (Actions.instance.actionEnabled) // If action is enabled, get all exits and calculate the closest position
        {
            if (UnityEngine.Input.GetMouseButtonDown(0))
            {
                EntityQuery agentQuery = GetEntityQuery(typeof(ExitComponent), ComponentType.ReadOnly<Translation>());

                exitsTranslations = new NativeArray<Translation>(agentQuery.CalculateEntityCount(), Allocator.TempJob);
                exitsTranslations = agentQuery.ToComponentDataArray<Translation>(Allocator.TempJob);

                finalExitPositions = new NativeArray<float3>(agentQuery.CalculateChunkCount(), Allocator.TempJob);
                for (int i = 0; i < exitsTranslations.Length - 1; i++)
                {
                    finalExitPositions[i] = exitsTranslations[i].Value;
                }
                var panicJob = new PanicJob
                {
                    CommandBuffer = m_EntityCommandBufferSystem.CreateCommandBuffer().ToConcurrent(),
                    exitsTranslations = finalExitPositions
                };

                jobHandle = panicJob.Schedule(this, inputDeps);
                exitsTranslations.Dispose();

            }
        }

        m_EntityCommandBufferSystem.AddJobHandleForProducer(jobHandle); // Execute the commandBuffer commands when spawnJob is finished
        return jobHandle;
    }
}
