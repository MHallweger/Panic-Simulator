using Unity.Entities;
using Unity.Jobs;
using Unity.Mathematics;
using Unity.Collections;
using Unity.Transforms;
using Unity.Burst;

// Priority
[UpdateBefore(typeof(MovingSystem))]
[UpdateBefore(typeof(ManagerSystem))]
[UpdateBefore(typeof(JumpingSystem))]
[UpdateBefore(typeof(CalculateNewRandomPositionSystem))]
/// <summary>
/// System that reacts on panic spots, generated by mouse click.
/// </summary>
public class PanicSystem : JobComponentSystem
{
    // For creating the commandBuffer
    EndSimulationEntityCommandBufferSystem m_EntityCommandBufferSystem;

    /// <summary>
    /// Initialize The EndSimulationEntityCommandBufferSystem commandBufferSystem.
    /// </summary>
    protected override void OnCreate()
    {
        m_EntityCommandBufferSystem = World.GetOrCreateSystem<EndSimulationEntityCommandBufferSystem>();
    }

    /// <summary>
    /// Calculates and saves the closest exit target.
    /// </summary>
    /// <param name="_agentPosition">Current Agent position</param>
    /// <param name="_agentComponent">Current Agent Component</param>
    /// <param name="_exitsTranslations">Current Exits</param>
    [BurstCompile]
    public static void CheckForClosestExit(float3 _agentPosition, [WriteOnly] ref AgentComponent _agentComponent, [ReadOnly] NativeArray<Translation> _exitsTranslations)
    {
        // Set first value as closest target
        float3 closestExit = _exitsTranslations[0].Value;

        // Loop through each exit and calculate if an exit is closer than the actual closest exit
        for (int i = 0; i < _exitsTranslations.Length; i++)
        {
            if (math.distance(_agentPosition, _exitsTranslations[i].Value) < math.distance(_agentPosition, closestExit))
            {
                closestExit = _exitsTranslations[i].Value;
            }
        }

        //If Agent can see an exit, set this exit as target
        _agentComponent.target = closestExit;
        _agentComponent.hasTarget = true;
        _agentComponent.foundFinalExitPoint = true;
        _agentComponent.foundTemporaryNewRandomPosition = false;
    }

    /// <summary>
    /// Every Agent in given radius gets the Panic AgentStatus.
    /// </summary>
    [BurstCompile]
    public struct EnablePanicModeJob : IJobForEachWithEntity<AgentComponent, Translation>
    {
        // Data from main thread
        [ReadOnly] public float panicRadius;
        [ReadOnly] public float3 actionPosition;

        public void Execute(Entity entity, int index, [WriteOnly] ref AgentComponent _agentComponent, [ReadOnly] ref Translation _translation)
        {
            if (math.distance(_translation.Value, actionPosition) <= panicRadius)
            {
                // Agent close to the action position
                // Enable Pre Panic Mode
                _agentComponent.agentStatus = AgentStatus.Running;
            }
        }
    }

    /// <summary>
    /// The main panic Job to calculate a panic reaction for each agent individually.
    /// </summary>
    [BurstCompile]
    public struct PanicJob : IJobForEachWithEntity<Translation, AgentComponent, BorderComponent>
    {
        // Data from main thread
        [ReadOnly] public NativeMultiHashMap<int, QuadrantData> quadrantMultiHashMap; // Quadrant HashMap
        [ReadOnly] public NativeArray<Translation> exitsTranslations; // Current Exit Translations
        [ReadOnly] public NativeArray<ExitComponent> exitsExitComponents; // Current Exit ExitComponents

        [NativeDisableParallelForRestriction] public NativeArray<Random> RandomGenerator; // Filled RandoGenerator
        [Unity.Collections.LowLevel.Unsafe.NativeSetThreadIndex] private int threadIndex; // Current Thread Index

        /// <summary>
        /// This Job is devided into three parts.
        /// Part 1: If there are any Agents with no target and a Running Tag (Agents near an explosion), calculate a random position and check if this random position is inside the festival area.
        /// If it's not inside the festival area, generate a new random position. If it's inside the festival area, set this random position to the new target of this agent. The Running Tag will react on this information.
        /// Part 2: Agent has a target and is running to this target. If the Agent can see an exit, check if this exit is not overloaded. 
        /// If it's overloaded, go to Part 1. If it's not overloaded, set this exit as target and set the foundFinalExitPosition bool to true.
        /// Part 3: Agents on the way to an exit are using this part. If they notice that the current Exit as their target is overloaded, calculate a random value.
        /// Compare this value with the current fleeProbability of themselfes. Basically the Agent decided randomly if it keeps the exit or not, to calculate a new random value like in Part 1.
        /// </summary>
        /// <param name="entity">Current entity</param>
        /// <param name="index">Current entity Index</param>
        /// <param name="_translation">Current Entity Translation Component</param>
        /// <param name="_agentComponent">Current Entity AgentComponent</param>
        /// <param name="_borderComponent">Current Entity BorderComponent</param>
        public void Execute(Entity entity, int index, [ReadOnly] ref Translation _translation, ref AgentComponent _agentComponent, [ReadOnly] ref BorderComponent _borderComponent)
        {
            // Random initialization
            var randomGenerator = RandomGenerator[threadIndex - 1];

            // This is necessary to update the state of the element inside the array.
            RandomGenerator[threadIndex - 1] = randomGenerator;
            var rnd = RandomGenerator[threadIndex - 1];

            // Generate a new random position on the map
            if (_agentComponent.agentStatus == AgentStatus.Running && !_agentComponent.hasTarget)
            {
                // Set target for enabling Running Job in Running System
                float3 randomGeneratedPanicPosition = float3.zero;
                float3 tempRandomPosition = float3.zero;
                while (randomGeneratedPanicPosition.Equals(float3.zero))
                {
                    // While the result float3 randomGeneratedPanicPosition = float3.zero
                    // Generate a random position on the map
                    // And calculate if this position is inside the festival Area
                    // Set this position to the new target if it's inside
                    tempRandomPosition = new float3(
                        rnd.NextFloat(_borderComponent.backRight.x, _borderComponent.backLeft.x),
                        .5f,
                        rnd.NextFloat(_borderComponent.frontLeft.z, _borderComponent.backLeft.z));

                    if (CalculateNewRandomPositionSystem.IsInsideFestivalArea(ref _borderComponent, tempRandomPosition))
                    {
                        // If tempRandomPosition is inside the festival Area, set this random Position and trigger the Running Job in the RunningSystem
                        randomGeneratedPanicPosition = tempRandomPosition;

                        _agentComponent.target = randomGeneratedPanicPosition;
                        _agentComponent.hasTarget = true;
                        _agentComponent.foundTemporaryNewRandomPosition = true;
                    }
                }
            }
            // Calculate nearest exit. Look on the exit and check if its overloaded. Only set this exit as target when its not overloaed
            else if (_agentComponent.agentStatus == AgentStatus.Running && _agentComponent.hasTarget && _agentComponent.foundTemporaryNewRandomPosition && !_agentComponent.foundFinalExitPoint && !_agentComponent.marked)
            {
                for (int i = 0; i < exitsTranslations.Length; i++)
                {
                    // Loop through each exit and calculate if this exit is close to me as an agent
                    if (math.distance(_translation.Value, exitsTranslations[i].Value) < 20f)
                    {
                        // If there is an exit that is close to me, check if this exit is overloaded
                        if (!exitsExitComponents[i].overloaded)
                        {
                            //If Agent can see an exit and this exit is not overloaded, set this exit as target
                            _agentComponent.target = exitsTranslations[i].Value;
                            _agentComponent.hasTarget = true;
                            _agentComponent.foundFinalExitPoint = true;
                            _agentComponent.foundTemporaryNewRandomPosition = false;
                        }
                        else
                        {
                            // If this exit is overloaded, go to Part 1
                            _agentComponent.hasTarget = false;
                        }
                    }
                }
            }
            // Agents notices on the way to the exit that this exis is overloaded now, randomly decide if it shall keep this exit or to choose another one
            if (_agentComponent.foundFinalExitPoint && _agentComponent.hasTarget)
            {
                // Agent runs to an exit
                for (int i = 0; i < exitsTranslations.Length; i++)
                {
                    // Loop through all exits and check if this exit is equals to the agents target
                    if (_agentComponent.target.Equals(exitsTranslations[i].Value))
                    {
                        // If this exit is overloaded, so the agents current target is overloaded
                        if (exitsExitComponents[i].overloaded)
                        {
                            // Calculate a random value and compare it with the agents current fleeProbability.
                            // Agents notices on the way to the exit that this exis is overloaded now, randomly decide if it shall keep this exit or to choose another one
                            float dice = rnd.NextFloat(1000f);

                            if (dice <= _agentComponent.fleeProbability)
                            {
                                _agentComponent.hasTarget = false;
                                _agentComponent.foundFinalExitPoint = false;
                                _agentComponent.marked = true;

                                // Take care of the fleeProbability, otherwise it will go negative.
                                // Set it to an static value of 0.11f when its below 0.0f
                                if (_agentComponent.fleeProbability - 5.55f < 0.0f)
                                {
                                    _agentComponent.fleeProbability = .11f;
                                }
                                else
                                {
                                    _agentComponent.fleeProbability -= 5.55f;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /// <summary>
    /// Job that handles the reaction of an agent when beeing in near of an agent that has panic and is in running mode.
    /// </summary>
    [BurstCompile]
    public struct ReactOnPanicInsideQuadrantJob : IJobForEachWithEntity<Translation, AgentComponent, QuadrantEntity>
    {
        // Data from main thread
        // instantiating and deleting of Entitys can only gets done on the main thread, save commands in buffer for main thread
        public EntityCommandBuffer.Concurrent CommandBuffer;

        [ReadOnly] public NativeMultiHashMap<int, QuadrantData> quadrantMultiHashMap; // Quadrant System HashMap
        [ReadOnly] public NativeArray<Translation> exitsTranslations; // Current exit Translation Components
        [ReadOnly] public NativeArray<ExitComponent> exitsExitComponents; // Current exit ExitComponents
        [ReadOnly] public float3 actionPosition; // position where panic appears

        [NativeDisableParallelForRestriction]
        [DeallocateOnJobCompletion]
        public NativeArray<Random> RandomGenerator; // Filled RandomGenerator

        [Unity.Collections.LowLevel.Unsafe.NativeSetThreadIndex]
        [ReadOnly]
        private int threadIndex; // Current thread Index

        /// <summary>
        /// Calculate random quadrants where The Method CalculatePanicReaction searches for matching entities.
        /// </summary>
        /// <param name="entity">Current Entity</param>
        /// <param name="index">Current entity index</param>
        /// <param name="_translation">Current entity Translation Component</param>
        /// <param name="_agentComponent">Current entity AgentComponent</param>
        /// <param name="_quadrantEntity">Current entity QuadrantEntity</param>
        public void Execute(Entity entity, int index, [ReadOnly] ref Translation _translation, ref AgentComponent _agentComponent, ref QuadrantEntity _quadrantEntity)
        {
            // Random initialization
            var randomGenerator = RandomGenerator[threadIndex - 1];
            RandomGenerator[threadIndex - 1] = randomGenerator; // This is necessary to update the state of the element inside the array.
            var rnd = RandomGenerator[threadIndex - 1];

            // Generate different random quadrant índices as index for the HashMapKeys
            int randomQuadrantSearchIndex = 0;
            if (_agentComponent.agentStatus == AgentStatus.Running)
            {
                randomQuadrantSearchIndex = rnd.NextInt(6, 10);
            }
            else
            {
                randomQuadrantSearchIndex = rnd.NextInt(1, 4);
            }

            // Calculate the correct quadrant for this agent
            int hashMapKey = QuadrantSystem.GetPositionHashMapKey(_translation.Value);

            // Call CalculatePanicReaction for each direction 
            CalculatePanicReaction(hashMapKey, ref _translation, ref _agentComponent, index, entity); // This quadrant itself (mid)
            CalculatePanicReaction(hashMapKey + randomQuadrantSearchIndex, ref _translation, ref _agentComponent, index, entity); // Right quadrant
            CalculatePanicReaction(hashMapKey - randomQuadrantSearchIndex, ref _translation, ref _agentComponent, index, entity); // Left quadrant
            CalculatePanicReaction(hashMapKey + QuadrantSystem.quadrantYMultiplier, ref _translation, ref _agentComponent, index, entity); // Above quadrant
            CalculatePanicReaction(hashMapKey - QuadrantSystem.quadrantYMultiplier, ref _translation, ref _agentComponent, index, entity); // Below quadrant

            CalculatePanicReaction(hashMapKey + randomQuadrantSearchIndex + QuadrantSystem.quadrantYMultiplier, ref _translation, ref _agentComponent, index, entity); // Corner Top Right
            CalculatePanicReaction(hashMapKey - randomQuadrantSearchIndex + QuadrantSystem.quadrantYMultiplier, ref _translation, ref _agentComponent, index, entity); // Corner Top Left
            CalculatePanicReaction(hashMapKey + randomQuadrantSearchIndex - QuadrantSystem.quadrantYMultiplier, ref _translation, ref _agentComponent, index, entity); // Corner Bottom Right
            CalculatePanicReaction(hashMapKey - randomQuadrantSearchIndex - QuadrantSystem.quadrantYMultiplier, ref _translation, ref _agentComponent, index, entity); // Corner Bottom Left
        }

        /// <summary>
        /// Case 1: Agent sees another agent which has the Running Tag as AgentStatus. Current Agent copy this behavior and also goes into Panic mode.
        /// Case 2: Agent sees another agent which runs to an exit. Current Agent copy this behavior and also runs to this exit.
        /// </summary>
        /// <param name="_hashMapKey">Passed calculated hashMap key</param>
        /// <param name="_translation">Passed entity Translation Component</param>
        /// <param name="_agentComponent">Passed entity AgentComponent</param>
        /// <param name="entityIndex">Passed entity Index</param>
        /// <param name="entity">Passed entity</param>
        [BurstCompile]
        private void CalculatePanicReaction([ReadOnly] int _hashMapKey, [ReadOnly] ref Translation _translation, ref AgentComponent _agentComponent, int entityIndex, Entity entity)
        {
            // Cycling through all entitys/agents inside this quadrant
            QuadrantData quadrantData;
            NativeMultiHashMapIterator<int> nativeMultiHashMapIterator;
            if (quadrantMultiHashMap.TryGetFirstValue(_hashMapKey, out quadrantData, out nativeMultiHashMapIterator))
            {
                do
                {
                    // Check if agent sees an agent with Running AgentStatus
                    // If this is the case, copy this Status and set it to Running
                    if (math.distance(_translation.Value, quadrantData.position) < 20
                        && quadrantData.agentComponent.agentStatus == AgentStatus.Running
                        && !quadrantData.agentComponent.exitPointReached // prevent stopping at exit
                        && !_agentComponent.exitPointReached // prevent stopping at exit
                        && _agentComponent.agentStatus != AgentStatus.Running) // prevent from adding Panic Tags again and again
                    {
                        _agentComponent.agentStatus = AgentStatus.Running;
                    }

                    // Check if agent sees an agent with a target.
                    // If this is the case, copy this target
                    if (quadrantData.agentComponent.foundFinalExitPoint
                        && !quadrantData.agentComponent.exitPointReached
                        && !_agentComponent.exitPointReached
                        && !_agentComponent.marked)
                    {
                        _agentComponent.target = quadrantData.agentComponent.target;
                        _agentComponent.foundFinalExitPoint = true;
                        _agentComponent.hasTarget = true;
                    }
                } while (quadrantMultiHashMap.TryGetNextValue(out quadrantData, ref nativeMultiHashMapIterator));
            }
        }
    }

    // Variables for not creating new ones each time OnUpdate restarts
    #region Variables
    float3 actionPosition;
    int actionMode;
    float panicRadius;
    Random Rnd = new Random(1);
    NativeArray<Random> RandomGenerator;
    #endregion // Variables

    /// <summary>
    /// Main Thread section, where Jobs are called and connected.
    /// </summary>
    /// <param name="inputDeps">starting deps</param>
    /// <returns>jobHandle</returns>
    protected override JobHandle OnUpdate(JobHandle inputDeps)
    {
        JobHandle jobHandle = new JobHandle();

        // Random Generator with a static ProcessorCount length
        // Used to generate individual random values inside a job
        RandomGenerator = new NativeArray<Random>(System.Environment.ProcessorCount, Allocator.TempJob);

        // Filled with random values
        // The access is via Thread Index later
        for (int i = 0; i < RandomGenerator.Length; i++)
        {
            RandomGenerator[i] = new Random((uint)Rnd.NextInt());
        }

        // React on different states of the Radial Menu and start specific jobs
        if (Actions.instance.actionEnabled)
        {
            // Get all exit entities
            EntityQuery exitQuery = GetEntityQuery(typeof(ExitComponent), ComponentType.ReadOnly<Translation>());

            // Extract Translation and ExitComponent Components
            NativeArray<Translation> exitsTranslations = exitQuery.ToComponentDataArray<Translation>(Allocator.TempJob);
            NativeArray<ExitComponent> exitsExitComponents = exitQuery.ToComponentDataArray<ExitComponent>(Allocator.TempJob);

            // If smallGroundExplosion Icon was choosen
            if (Actions.instance.smallGroundExplosion)
            {
                // If User pressed left mouse button down
                if (UnityEngine.Input.GetMouseButtonDown(0))
                {
                    // Handle the mouse position and pass it to the EnablePanicModeJob later
                    actionPosition = UnityEngine.Input.mousePosition;
                    UnityEngine.Ray ray = UnityEngine.Camera.main.ScreenPointToRay(actionPosition);
                    if (UnityEngine.Physics.Raycast(ray, out UnityEngine.RaycastHit hit))
                    {
                        if (hit.collider != null)
                        {
                            actionPosition = new float3(hit.point.x, .5f, hit.point.z);
                        }
                    }

                    // Create EnablePanicModeJob which creates a panic reaction around the action effect
                    EnablePanicModeJob enablePrePanicJob = new EnablePanicModeJob
                    {
                        actionPosition = actionPosition,
                        panicRadius = 5f,
                    };

                    // Schedule the EnablePanicModeJob Job with starting deps, save results into JobHandle
                    jobHandle = enablePrePanicJob.Schedule(this, inputDeps);
                }

                // When choosen, always start a panic job to simulate panic behavior
                // Create Panic Job
                PanicJob panicJob = new PanicJob
                {
                    RandomGenerator = RandomGenerator,
                    exitsTranslations = exitsTranslations,
                    exitsExitComponents = exitsExitComponents,
                    quadrantMultiHashMap = QuadrantSystem.quadrantMultiHashMap
                };

                // Schedule Panic Job
                jobHandle = panicJob.Schedule(this, jobHandle);
            }

            // If mediumGroundExplosion Icon was choosen
            else if (Actions.instance.mediumGroundExplosion)
            {
                // If User pressed left mouse button down
                if (UnityEngine.Input.GetMouseButtonDown(0))
                {
                    // Handle the mouse position and pass it to the EnablePanicModeJob later
                    actionPosition = UnityEngine.Input.mousePosition;
                    UnityEngine.Ray ray = UnityEngine.Camera.main.ScreenPointToRay(actionPosition);
                    if (UnityEngine.Physics.Raycast(ray, out UnityEngine.RaycastHit hit))
                    {
                        if (hit.collider != null)
                        {
                            actionPosition = new float3(hit.point.x, .5f, hit.point.z);
                        }
                    }

                    // Create EnablePanicModeJob which creates a panic reaction around the action effect
                    EnablePanicModeJob enablePrePanicJob = new EnablePanicModeJob
                    {
                        actionPosition = actionPosition,
                        panicRadius = 10f,
                    };

                    // Schedule the EnablePanicModeJob with starting deps, save results into JobHandle
                    jobHandle = enablePrePanicJob.Schedule(this, inputDeps);
                }

                // When choosen, always start a panic job to simulate panic behavior
                // Create Panic Job
                PanicJob panicJob = new PanicJob
                {
                    RandomGenerator = RandomGenerator,
                    exitsTranslations = exitsTranslations,
                    exitsExitComponents = exitsExitComponents,
                    quadrantMultiHashMap = QuadrantSystem.quadrantMultiHashMap
                };

                // Schedule Panic Job
                jobHandle = panicJob.Schedule(this, jobHandle);
            }

            // If bigGroundExplosion Icon was choosen
            else if (Actions.instance.bigGroundExplosion)
            {
                // If User pressed left mouse button down
                if (UnityEngine.Input.GetMouseButtonDown(0))
                {
                    // Handle the mouse position and pass it to the EnablePanicModeJob later
                    actionPosition = UnityEngine.Input.mousePosition;
                    UnityEngine.Ray ray = UnityEngine.Camera.main.ScreenPointToRay(actionPosition);
                    if (UnityEngine.Physics.Raycast(ray, out UnityEngine.RaycastHit hit))
                    {
                        if (hit.collider != null)
                        {
                            actionPosition = new float3(hit.point.x, .5f, hit.point.z);
                        }
                    }

                    // Create EnablePanicModeJob which creates a panic reaction around the action effect
                    EnablePanicModeJob enablePrePanicJob = new EnablePanicModeJob
                    {
                        actionPosition = actionPosition,
                        panicRadius = 15f,
                    };

                    // Schedule the EnablePanicModeJob Job with starting deps, save results into JobHandle
                    jobHandle = enablePrePanicJob.Schedule(this, inputDeps);
                }

                // When choosen, always start a panic job to simulate panic behavior
                // Create Panic Job
                PanicJob panicJob = new PanicJob
                {
                    RandomGenerator = RandomGenerator,
                    exitsTranslations = exitsTranslations,
                    exitsExitComponents = exitsExitComponents,
                    quadrantMultiHashMap = QuadrantSystem.quadrantMultiHashMap
                };

                // Schedule Panic Job
                jobHandle = panicJob.Schedule(this, jobHandle);
            }

            // If smallGroundExplosion Icon was choosen
            else if (Actions.instance.fire)
            {
                // If User pressed left mouse button down
                if (UnityEngine.Input.GetMouseButtonDown(0))
                {
                    // Handle the mouse position and pass it to the EnablePanicModeJob later
                    // Check if the clicked position is a Sound System
                    // Disable Information Arrows
                    actionPosition = UnityEngine.Input.mousePosition;
                    UnityEngine.Ray ray = UnityEngine.Camera.main.ScreenPointToRay(actionPosition);
                    if (UnityEngine.Physics.Raycast(ray, out UnityEngine.RaycastHit hit))
                    {
                        if (hit.collider != null)
                        {
                            string hittedGameObjectName = hit.collider.gameObject.name;
                            if (hittedGameObjectName == "Sound System"
                                || hittedGameObjectName == "Sound System_2"
                                || hittedGameObjectName == "Sound System_3"
                                || hittedGameObjectName == "Sound System_4"
                                || hittedGameObjectName == "Sound System_5"
                                || hittedGameObjectName == "Sound System(Clone)")
                            {
                                actionPosition = new float3(hit.point.x, .5f, hit.point.z);
                                hit.collider.gameObject.GetComponent<InformationAnimationSoundSystem>().enabled = false;
                                hit.collider.gameObject.transform.GetChild(0).gameObject.SetActive(false);
                            }
                            hittedGameObjectName = null;
                        }
                    }

                    // Create EnablePanicModeJob which creates a panic reaction around the action effect
                    EnablePanicModeJob enablePrePanicJob = new EnablePanicModeJob
                    {
                        actionPosition = actionPosition,
                        panicRadius = 10f,
                    };

                    // Schedule the EnablePanicModeJob Job with starting deps, save results into JobHandle
                    jobHandle = enablePrePanicJob.Schedule(this, inputDeps);
                }

                // When choosen, always start a panic job to simulate panic behavior
                // Create Panic Job
                PanicJob panicJob = new PanicJob
                {
                    RandomGenerator = RandomGenerator,
                    exitsTranslations = exitsTranslations,
                    exitsExitComponents = exitsExitComponents,
                    quadrantMultiHashMap = QuadrantSystem.quadrantMultiHashMap
                };

                // Schedule Panic Job
                jobHandle = panicJob.Schedule(this, jobHandle);
            }

            // If smallGroundExplosion Icon was choosen
            else if (Actions.instance.fallingTruss)
            {
                // If User pressed left mouse button down
                if (UnityEngine.Input.GetMouseButtonDown(0))
                {
                    // Handle the mouse position and pass it to the EnablePanicModeJob later
                    // Disable Information Arrows
                    actionPosition = UnityEngine.Input.mousePosition;
                    UnityEngine.Ray ray = UnityEngine.Camera.main.ScreenPointToRay(actionPosition);
                    if (UnityEngine.Physics.Raycast(ray, out UnityEngine.RaycastHit hit))
                    {
                        if (hit.collider != null)
                        {
                            actionPosition = hit.collider.gameObject.transform.position; // The position of the falling truss Game Object
                            hit.collider.gameObject.GetComponent<InformationAnimationTruss>().enabled = false;
                            hit.collider.gameObject.transform.GetChild(0).gameObject.SetActive(false);
                        }
                    }
                }

                // This bool will be true, when the falling truss animation has completed with Unity events
                // Only create the panic reaction when the truss has fallen 
                if (Actions.instance.trussHasFallen)
                {
                    // Create EnablePanicModeJob which creates a panic reaction around the action effect
                    EnablePanicModeJob enablePrePanicJob = new EnablePanicModeJob
                    {
                        actionPosition = actionPosition,
                        panicRadius = 25f,
                    };

                    // Schedule the EnablePanicModeJob Job with starting deps, save results into JobHandle
                    jobHandle = enablePrePanicJob.Schedule(this, inputDeps);
                }

                // When choosen, always start a panic job to simulate panic behavior
                // Create Panic Job
                PanicJob panicJob = new PanicJob
                {
                    RandomGenerator = RandomGenerator,
                    exitsTranslations = exitsTranslations,
                    exitsExitComponents = exitsExitComponents,
                    quadrantMultiHashMap = QuadrantSystem.quadrantMultiHashMap
                };

                // Schedule Panic Job
                jobHandle = panicJob.Schedule(this, jobHandle);
            }

            // Case: No Exits, Agents spawned, action placed, 2 pressed to remove all agents, 1 pressed to spawn agents again -> panic still enabled
            // Only start the ReactOnPanicInsideQuadrantJob when allowed (mouse pressed down)
            if (ManagerSystem.actionUsed)
            {
                // Only React on panic when panic action is enabled
                ReactOnPanicInsideQuadrantJob reactOnPanicInsideQuadrantJob = new ReactOnPanicInsideQuadrantJob
                {
                    quadrantMultiHashMap = QuadrantSystem.quadrantMultiHashMap,
                    exitsTranslations = exitsTranslations,
                    exitsExitComponents = exitsExitComponents,
                    actionPosition = actionPosition,
                    RandomGenerator = RandomGenerator,
                    CommandBuffer = m_EntityCommandBufferSystem.CreateCommandBuffer().ToConcurrent(), // Create the commandBuffer
                };

                // Schedule ReactOnPanicInsideQuadrantJob
                jobHandle = reactOnPanicInsideQuadrantJob.Schedule(this, jobHandle);

                // Execute the commandBuffer commands when reactOnPanicInsideQuadrantJob is finished
                m_EntityCommandBufferSystem.AddJobHandleForProducer(jobHandle); 
            }

        }
        // For writing on the multiHashMap (Quadrant System)
        jobHandle.Complete();
        return jobHandle;
    }
}
