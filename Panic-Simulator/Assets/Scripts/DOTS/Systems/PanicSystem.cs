using Unity.Entities;
using Unity.Jobs;
using Unity.Mathematics;
using Unity.Collections;
using Unity.Transforms;
using Unity.Burst;

[UpdateBefore(typeof(MovingSystem))]
[UpdateBefore(typeof(ManagerSystem))]
[UpdateBefore(typeof(JumpingSystem))]
[UpdateBefore(typeof(CalculateNewRandomPositionSystem))]
/// <summary>
/// System that reacts on panic spots, generated by mouse click.
/// </summary>
public class PanicSystem : JobComponentSystem
{
    EndSimulationEntityCommandBufferSystem m_EntityCommandBufferSystem; // For creating the commandBuffer

    /// <summary>
    /// Initialize The EndSimulationEntityCommandBufferSystem commandBufferSystem.
    /// </summary>
    protected override void OnCreate()
    {
        m_EntityCommandBufferSystem = World.GetOrCreateSystem<EndSimulationEntityCommandBufferSystem>();
    }

    [BurstCompile]
    public static void CheckForClosestExit(float3 agentPosition/*, float3 collisionPosition, float panicRadius*/, ref AgentComponent agentComponent,
        NativeArray<Translation> exitsTranslations/*, Translation excludedTranslation = new Translation()*//*, float3 actionPosition*/)
    {
        float3 closestExit = exitsTranslations[0].Value;
        for (int i = 0; i < exitsTranslations.Length; i++)
        {
            if (math.distance(agentPosition, exitsTranslations[i].Value) < math.distance(agentPosition, closestExit))
            {
                closestExit = exitsTranslations[i].Value;
            }
        }
        //If Agent can see an exit, set this exit as target
        agentComponent.target = closestExit;
        agentComponent.hasTarget = true;
        agentComponent.foundFinalExitPoint = true;
        agentComponent.foundTemporaryNewRandomPosition = false;
    }

    //public static void AgentAmountCheck(NativeArray<Translation> exitsTranslations, ref AgentComponent agentComponent, float3 agentPosition,
    //    NativeMultiHashMap<int, QuadrantData> quadrantMultiHashMap)
    //{
    //    // Agent found exit and runs to it
    //    //if (exitsTranslations.Length > 1) // If there are more than 1 exits, decide which one contains less agents
    //    //{
    //    // In this period calculate the current amount of agents that are around this exit
    //    if (agentComponent.foundFinalExitPoint)
    //    {
    //        for (int i = 0; i < exitsTranslations.Length; i++)
    //        {
    //            if (agentComponent.target.Equals(exitsTranslations[i].Value))
    //            {
    //                if (QuadrantSystem.GetEntityCountInHashMap(quadrantMultiHashMap, QuadrantSystem.GetPositionHashMapKey(exitsTranslations[i].Value)) > 3)
    //                {
    //                    // If the Amunt is higher than 100, do
    //                    //CheckForClosestExit(agentPosition, ref agentComponent, exitsTranslations, excludedTranslation: exitsTranslations[i]);
    //                    agentComponent.agentStatus = AgentStatus.Running;
    //                    agentComponent.hasTarget = false;
    //                    agentComponent.testing = true;
    //                }
    //            }
    //        }
    //    }
    //    //}
    //}

    /// <summary>
    /// Every Agent in given radius gets the Panic AgentStatus
    /// </summary>
    [BurstCompile] //TODO: einen neuen Job erstellen, welcher den command Buffer teil übernimmt
    public struct EnablePanicModeJob : IJobForEachWithEntity<AgentComponent, Translation>
    {
        public EntityCommandBuffer.Concurrent CommandBuffer; // instantiating and deleting of Entitys can only gets done on the main thread, save commands in buffer for main thread

        [ReadOnly]
        public float panicRadius;

        [ReadOnly]
        public float3 actionPosition;

        public void Execute(Entity entity, int index, ref AgentComponent agentComponent, [ReadOnly] ref Translation translation)
        {
            if (math.distance(translation.Value, actionPosition) <= panicRadius)
            {
                // Agent close to the action position
                // Enable Pre Panic Mode
                agentComponent.agentStatus = AgentStatus.Running;

                //CommandBuffer.AddComponent<PanicTag>(index, entity);
            }
        }
    }

    [BurstCompile]
    public struct PanicJob : IJobForEachWithEntity<Translation, AgentComponent, BorderComponent>
    {
        [ReadOnly]
        public NativeMultiHashMap<int, QuadrantData> quadrantMultiHashMap;

        [ReadOnly] public NativeArray<Translation> exitsTranslations;
        [ReadOnly] public NativeArray<ExitComponent> exitsExitComponents;


        public float3 actionPosition; // The spot where the action arised

        [NativeDisableParallelForRestriction]
        //[DeallocateOnJobCompletion]
        public NativeArray<Random> RandomGenerator;

        [Unity.Collections.LowLevel.Unsafe.NativeSetThreadIndex]
        private int threadIndex;

        public void Execute(Entity entity, int index, [ReadOnly] ref Translation translation, ref AgentComponent agentComponent, [ReadOnly] ref BorderComponent borderComponent)
        {
            var randomGenerator = RandomGenerator[threadIndex - 1];

            RandomGenerator[threadIndex - 1] = randomGenerator; //This is necessary to update the state of the element inside the array.

            var rnd = RandomGenerator[threadIndex - 1];

            // Generate new random position on map
            if (agentComponent.agentStatus == AgentStatus.Running && !agentComponent.hasTarget /*&& !agentComponent.exitPointReached*/)
            {
                // Generate random position on map
                // Set target for enabling Running Job in Running System
                float3 randomGeneratedPanicPosition = float3.zero;
                float3 tempRandomPosition = float3.zero;
                while (randomGeneratedPanicPosition.Equals(float3.zero))
                {
                    tempRandomPosition = new float3(
                        rnd.NextFloat(borderComponent.backRight.x, borderComponent.backLeft.x),
                        .5f,
                        rnd.NextFloat(borderComponent.frontLeft.z, borderComponent.backLeft.z));

                    if (CalculateNewRandomPositionSystem.IsInsideFestivalArea(ref borderComponent, tempRandomPosition))
                    {
                        // If tempRandomPosition is inside the festival Area, set this random Position and trigger the Running Job in the RunningSystem
                        randomGeneratedPanicPosition = tempRandomPosition;

                        agentComponent.target = randomGeneratedPanicPosition;
                        agentComponent.hasTarget = true;
                        agentComponent.foundTemporaryNewRandomPosition = true;
                    }
                }
            }
            // Calculate nearest exit. Look on the exit and check if its overloaded. Only set this exit as target when its not overloaed
            else if (agentComponent.agentStatus == AgentStatus.Running && agentComponent.hasTarget && agentComponent.foundTemporaryNewRandomPosition && !agentComponent.foundFinalExitPoint && !agentComponent.marked)
            {
                for (int i = 0; i < exitsTranslations.Length; i++)
                {
                    if (math.distance(translation.Value, exitsTranslations[i].Value) < 20f) // Agents in der Nähe von 20 meiden einen exit der überladen ist
                    {
                        if (!exitsExitComponents[i].overloaded /*&& !agentComponent.marked*/)
                        {
                            //If Agent can see an exit, set this exit as target
                            agentComponent.target = exitsTranslations[i].Value;
                            agentComponent.hasTarget = true;
                            agentComponent.foundFinalExitPoint = true;
                            agentComponent.foundTemporaryNewRandomPosition = false;
                        }
                        else
                        {
                            agentComponent.hasTarget = false;
                        }
                    }
                    //else if (math.distance(translation.Value, exitsTranslations[i].Value) >= 20.0f)
                    //{
                    //    // Every Agent with distance greater than 40 will look on the overloaded bool on this exit
                    //    float dice = rnd.NextFloat(10000.0f);

                    //    if (dice <= 3)
                    //    {
                    //        agentComponent.target = exitsTranslations[i].Value;
                    //        agentComponent.hasTarget = true;
                    //        agentComponent.foundFinalExitPoint = true;
                    //        agentComponent.foundTemporaryNewRandomPosition = false;

                    //        agentComponent.discoverProbability += 5.5f; // Increase the probability for running to an exit where a lot of agents are 

                    //    }
                    //    else
                    //    {
                    //        agentComponent.hasTarget = false;
                    //    }
                    //}
                }
            }
            if (agentComponent.foundFinalExitPoint && agentComponent.hasTarget)
            {
                // Agent runs to an exit
                for (int i = 0; i < exitsTranslations.Length; i++)
                {
                    if (agentComponent.target.Equals(exitsTranslations[i].Value))
                    {
                        if (exitsExitComponents[i].overloaded)
                        {
                            // Agents notices on the way to the exit that this exis is overloaded now, randomly decide if it shall keep this exit or to choose another one

                            float dice = rnd.NextFloat(1000f);

                            if (dice <= agentComponent.fleeProbability)
                            {
                                agentComponent.hasTarget = false;
                                agentComponent.foundFinalExitPoint = false;
                                agentComponent.marked = true;

                                if (agentComponent.fleeProbability - 5.55f < 0.0f)
                                {
                                    agentComponent.fleeProbability = .11f;
                                }
                                else
                                {
                                    agentComponent.fleeProbability -= 5.55f;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    [BurstCompile]
    public struct WakeUpInactiveAgents : IJobForEachWithEntity<AgentComponent, Translation>
    {
        [ReadOnly] public int panicTagAmount;
        [ReadOnly] public int agentAmount;
        [ReadOnly] public int escapedTagAmount;
        public EntityCommandBuffer.Concurrent CommandBuffer; // instantiating and deleting of Entitys can only gets done on the main thread, save commands in buffer for main thread
        [ReadOnly] public NativeArray<Translation> exitsTranslations;

        [NativeDisableParallelForRestriction]
        //[DeallocateOnJobCompletion]
        public NativeArray<Random> RandomGenerator;

        [Unity.Collections.LowLevel.Unsafe.NativeSetThreadIndex]
        private int threadIndex;

        public void Execute(Entity entity, int index, ref AgentComponent agentComponent, ref Translation translation)
        {
            var randomGenerator = RandomGenerator[threadIndex - 1];

            RandomGenerator[threadIndex - 1] = randomGenerator; //This is necessary to update the state of the element inside the array.

            var rnd = RandomGenerator[threadIndex - 1];

            if (!(panicTagAmount == agentAmount) && !agentComponent.exitPointReached)
            {
                if (agentComponent.agentStatus != AgentStatus.Running)
                {
                    if (panicTagAmount > (agentAmount / 100) * 85) // panicTagAmount greater than 85%?
                    {
                        agentComponent.agentStatus = AgentStatus.Running;
                        //CommandBuffer.AddComponent<PanicTag>(index, entity);
                    }
                }

                if (escapedTagAmount > (agentAmount / 100) * 90) // If panicTagAmount is less than 10% of agentAmount
                {
                    CheckForClosestExit(translation.Value, ref agentComponent, exitsTranslations);
                }
            }
        }
    }

    /// <summary>
    /// Job that handles the reaction of an agent when beeing in near of an agent that has panic and is in running mode.
    /// </summary>
    [BurstCompile]
    public struct ReactOnPanicInsideQuadrantJob : IJobForEachWithEntity<Translation, AgentComponent, QuadrantEntity>
    {
        public EntityCommandBuffer.Concurrent CommandBuffer; // instantiating and deleting of Entitys can only gets done on the main thread, save commands in buffer for main thread

        [ReadOnly]
        public NativeMultiHashMap<int, QuadrantData> quadrantMultiHashMap;

        [ReadOnly]
        public NativeArray<Translation> exitsTranslations;

        [ReadOnly]
        public NativeArray<ExitComponent> exitsExitComponents;

        [ReadOnly]
        public float3 actionPosition; // position where panic appears

        [NativeDisableParallelForRestriction]
        [DeallocateOnJobCompletion]
        public NativeArray<Random> RandomGenerator;

        [Unity.Collections.LowLevel.Unsafe.NativeSetThreadIndex]
        private int threadIndex;

        public void Execute(Entity entity, int index, [ReadOnly] ref Translation translation, ref AgentComponent agentComponent, ref QuadrantEntity quadrantEntity)
        {
            var randomGenerator = RandomGenerator[threadIndex - 1];
            RandomGenerator[threadIndex - 1] = randomGenerator; //This is necessary to update the state of the element inside the array.
            var rnd = RandomGenerator[threadIndex - 1];

            int randomQuadrantSearchIndex = 0;
            if (agentComponent.agentStatus == AgentStatus.Running)
            {
                randomQuadrantSearchIndex = rnd.NextInt(6, 10);
            }
            else
            {
                randomQuadrantSearchIndex = rnd.NextInt(1, 4);
            }

            // vorher waren das einsen
            int hashMapKey = QuadrantSystem.GetPositionHashMapKey(translation.Value); // Calculate the correct quadrant for this agent
            CalculatePanicReaction(hashMapKey, ref translation, ref agentComponent, index, entity); // This quadrant itself (mid)
            CalculatePanicReaction(hashMapKey + randomQuadrantSearchIndex, ref translation, ref agentComponent, index, entity); // Right quadrant
            CalculatePanicReaction(hashMapKey - randomQuadrantSearchIndex, ref translation, ref agentComponent, index, entity); // Left quadrant
            CalculatePanicReaction(hashMapKey + QuadrantSystem.quadrantYMultiplier, ref translation, ref agentComponent, index, entity); // Above quadrant
            CalculatePanicReaction(hashMapKey - QuadrantSystem.quadrantYMultiplier, ref translation, ref agentComponent, index, entity); // Below quadrant

            CalculatePanicReaction(hashMapKey + randomQuadrantSearchIndex + QuadrantSystem.quadrantYMultiplier, ref translation, ref agentComponent, index, entity); // Corner Top Right
            CalculatePanicReaction(hashMapKey - randomQuadrantSearchIndex + QuadrantSystem.quadrantYMultiplier, ref translation, ref agentComponent, index, entity); // Corner Top Left
            CalculatePanicReaction(hashMapKey + randomQuadrantSearchIndex - QuadrantSystem.quadrantYMultiplier, ref translation, ref agentComponent, index, entity); // Corner Bottom Right
            CalculatePanicReaction(hashMapKey - randomQuadrantSearchIndex - QuadrantSystem.quadrantYMultiplier, ref translation, ref agentComponent, index, entity); // Corner Bottom Left
        }

        //[BurstDiscard]
        private void CalculatePanicReaction(int hashMapKey, ref Translation translation, ref AgentComponent agentComponent, int entityIndex, Entity entity)
        {
            // Cycling through all entitys/agents inside this quadrant
            // Check if you as an agent sees an agent with panic running to you (5f)
            // You see that he has panic so you will have panic to.
            // You adept his target because you want to run to the same place
            // You start running
            QuadrantData quadrantData;
            NativeMultiHashMapIterator<int> nativeMultiHashMapIterator;
            if (quadrantMultiHashMap.TryGetFirstValue(hashMapKey, out quadrantData, out nativeMultiHashMapIterator))
            {
                do
                {
                    if (math.distance(translation.Value, quadrantData.position) < 20
                        && quadrantData.agentComponent.agentStatus == AgentStatus.Running
                        && !quadrantData.agentComponent.exitPointReached // prevent stopping at exit
                        && !agentComponent.exitPointReached // prevent stopping at exit
                        && agentComponent.agentStatus != AgentStatus.Running) // prevent from adding Panic Tags again and again
                    {
                        agentComponent.agentStatus = AgentStatus.Running;
                        //CommandBuffer.AddComponent<PanicTag>(entityIndex, entity);
                    }

                    if (/*math.distance(translation.Value, quadrantData.position) < 30
                        && */quadrantData.agentComponent.foundFinalExitPoint
                        && !quadrantData.agentComponent.exitPointReached
                        && !agentComponent.exitPointReached
                        && !agentComponent.marked)
                    {
                        agentComponent.target = quadrantData.agentComponent.target;
                        agentComponent.foundFinalExitPoint = true;
                        agentComponent.hasTarget = true;
                    }
                } while (quadrantMultiHashMap.TryGetNextValue(out quadrantData, ref nativeMultiHashMapIterator));
            }
        }
    }


    float3 actionPosition;
    int actionMode;
    float panicRadius;
    Random Rnd = new Random(1);
    NativeArray<Random> RandomGenerator;
    /// <summary>
    /// Runs on main thread, 1 times per frame
    /// </summary>
    /// <param name="inputDeps"></param>
    /// <returns></returns>
    protected override JobHandle OnUpdate(JobHandle inputDeps)
    {
        JobHandle jobHandle = new JobHandle();
        RandomGenerator = new NativeArray<Random>(System.Environment.ProcessorCount, Allocator.TempJob);

        //EntityQuery entityPanicTagQuery = GetEntityQuery(typeof(PanicTag));
        //EntityQuery entityEscapedTagQuery = GetEntityQuery(typeof(EscapedTag));
        //EntityQuery agentQuery = GetEntityQuery(typeof(AgentComponent));
        //NativeArray<PanicTag> panicTagComponents = entityPanicTagQuery.ToComponentDataArray<PanicTag>(Allocator.TempJob);
        //NativeArray<EscapedTag> escapedTagComponets = entityEscapedTagQuery.ToComponentDataArray<EscapedTag>(Allocator.TempJob);

        for (int i = 0; i < RandomGenerator.Length; i++)
        {
            RandomGenerator[i] = new Random((uint)Rnd.NextInt());
        }

        if (Actions.instance.actionEnabled) // If action is enabled, get all exits and calculate the closest position
        {
            EntityQuery exitQuery = GetEntityQuery(typeof(ExitComponent), ComponentType.ReadOnly<Translation>());

            NativeArray<Translation> exitsTranslations = exitQuery.ToComponentDataArray<Translation>(Allocator.TempJob);
            NativeArray<ExitComponent> exitsExitComponents = exitQuery.ToComponentDataArray<ExitComponent>(Allocator.TempJob);

            if (Actions.instance.smallGroundExplosion)
            {
                if (UnityEngine.Input.GetMouseButtonDown(0))
                {
                    // Small Explosions in Radial menu was selected
                    actionPosition = UnityEngine.Input.mousePosition;
                    UnityEngine.Ray ray = UnityEngine.Camera.main.ScreenPointToRay(actionPosition);
                    if (UnityEngine.Physics.Raycast(ray, out UnityEngine.RaycastHit hit))
                    {
                        if (hit.collider != null)
                        {
                            actionPosition = new float3(hit.point.x, .5f, hit.point.z);
                        }
                    }

                    EnablePanicModeJob enablePrePanicJob = new EnablePanicModeJob
                    {
                        actionPosition = actionPosition,
                        panicRadius = 5f,
                        CommandBuffer = m_EntityCommandBufferSystem.CreateCommandBuffer().ToConcurrent(), // Create the commandBuffer
                    };
                    jobHandle = enablePrePanicJob.Schedule(this, inputDeps);
                    m_EntityCommandBufferSystem.AddJobHandleForProducer(jobHandle); // Execute the commandBuffer commands when spawnJob is finished
                }

                PanicJob panicJob = new PanicJob
                {
                    actionPosition = actionPosition,
                    RandomGenerator = RandomGenerator,
                    exitsTranslations = exitsTranslations,
                    exitsExitComponents = exitsExitComponents,
                    quadrantMultiHashMap = QuadrantSystem.quadrantMultiHashMap
                };

                jobHandle = panicJob.Schedule(this, jobHandle);

                //WakeUpInactiveAgents wakeUpInactiveAgents = new WakeUpInactiveAgents
                //{
                //    agentAmount = agentQuery.CalculateEntityCount(),
                //    panicTagAmount = panicTagComponents.Length,
                //    CommandBuffer = m_EntityCommandBufferSystem.CreateCommandBuffer().ToConcurrent(),
                //    RandomGenerator = RandomGenerator,
                //    exitsTranslations = exitsTranslations,
                //    escapedTagAmount = escapedTagComponets.Length
                //};

                //jobHandle = wakeUpInactiveAgents.Schedule(this, jobHandle);
                //m_EntityCommandBufferSystem.AddJobHandleForProducer(jobHandle); // Execute the commandBuffer commands when spawnJob is finished
            }

            else if (Actions.instance.mediumGroundExplosion)
            {
                if (UnityEngine.Input.GetMouseButtonDown(0))
                {
                    // Small Explosions in Radial menu was selected
                    actionPosition = UnityEngine.Input.mousePosition;
                    UnityEngine.Ray ray = UnityEngine.Camera.main.ScreenPointToRay(actionPosition);
                    if (UnityEngine.Physics.Raycast(ray, out UnityEngine.RaycastHit hit))
                    {
                        if (hit.collider != null)
                        {
                            actionPosition = new float3(hit.point.x, .5f, hit.point.z);
                        }
                    }

                    EnablePanicModeJob enablePrePanicJob = new EnablePanicModeJob
                    {
                        actionPosition = actionPosition,
                        panicRadius = 10f,
                        CommandBuffer = m_EntityCommandBufferSystem.CreateCommandBuffer().ToConcurrent(), // Create the commandBuffer
                    };
                    jobHandle = enablePrePanicJob.Schedule(this, inputDeps);
                    m_EntityCommandBufferSystem.AddJobHandleForProducer(jobHandle); // Execute the commandBuffer commands when spawnJob is finished
                }

                PanicJob panicJob = new PanicJob
                {
                    actionPosition = actionPosition,
                    RandomGenerator = RandomGenerator,
                    exitsTranslations = exitsTranslations,
                    exitsExitComponents = exitsExitComponents,
                    quadrantMultiHashMap = QuadrantSystem.quadrantMultiHashMap
                };

                jobHandle = panicJob.Schedule(this, jobHandle);

                //WakeUpInactiveAgents wakeUpInactiveAgents = new WakeUpInactiveAgents
                //{
                //    agentAmount = agentQuery.CalculateEntityCount(),
                //    panicTagAmount = panicTagComponents.Length,
                //    CommandBuffer = m_EntityCommandBufferSystem.CreateCommandBuffer().ToConcurrent(),
                //    RandomGenerator = RandomGenerator,
                //    exitsTranslations = exitsTranslations,
                //    escapedTagAmount = escapedTagComponets.Length
                //};

                //jobHandle = wakeUpInactiveAgents.Schedule(this, jobHandle);
                //m_EntityCommandBufferSystem.AddJobHandleForProducer(jobHandle); // Execute the commandBuffer commands when spawnJob is finished
            }

            else if (Actions.instance.bigGroundExplosion)
            {
                if (UnityEngine.Input.GetMouseButtonDown(0))
                {
                    // Small Explosions in Radial menu was selected
                    actionPosition = UnityEngine.Input.mousePosition;
                    UnityEngine.Ray ray = UnityEngine.Camera.main.ScreenPointToRay(actionPosition);
                    if (UnityEngine.Physics.Raycast(ray, out UnityEngine.RaycastHit hit))
                    {
                        if (hit.collider != null)
                        {
                            actionPosition = new float3(hit.point.x, .5f, hit.point.z);
                        }
                    }

                    EnablePanicModeJob enablePrePanicJob = new EnablePanicModeJob
                    {
                        actionPosition = actionPosition,
                        panicRadius = 15f,
                        CommandBuffer = m_EntityCommandBufferSystem.CreateCommandBuffer().ToConcurrent(), // Create the commandBuffer
                    };
                    jobHandle = enablePrePanicJob.Schedule(this, inputDeps);
                    m_EntityCommandBufferSystem.AddJobHandleForProducer(jobHandle); // Execute the commandBuffer commands when spawnJob is finished
                }

                PanicJob panicJob = new PanicJob
                {
                    actionPosition = actionPosition,
                    RandomGenerator = RandomGenerator,
                    exitsTranslations = exitsTranslations,
                    exitsExitComponents = exitsExitComponents,
                    quadrantMultiHashMap = QuadrantSystem.quadrantMultiHashMap
                };

                jobHandle = panicJob.Schedule(this, jobHandle);

                //WakeUpInactiveAgents wakeUpInactiveAgents = new WakeUpInactiveAgents
                //{
                //    agentAmount = agentQuery.CalculateEntityCount(),
                //    panicTagAmount = panicTagComponents.Length,
                //    CommandBuffer = m_EntityCommandBufferSystem.CreateCommandBuffer().ToConcurrent(),
                //    RandomGenerator = RandomGenerator,
                //    exitsTranslations = exitsTranslations,
                //    escapedTagAmount = escapedTagComponets.Length
                //};

                //jobHandle = wakeUpInactiveAgents.Schedule(this, jobHandle);
                //m_EntityCommandBufferSystem.AddJobHandleForProducer(jobHandle); // Execute the commandBuffer commands when spawnJob is finished
            }

            else if (Actions.instance.fire)
            {
                if (UnityEngine.Input.GetMouseButtonDown(0))
                {
                    // Small Explosions in Radial menu was selected
                    actionPosition = UnityEngine.Input.mousePosition;
                    UnityEngine.Ray ray = UnityEngine.Camera.main.ScreenPointToRay(actionPosition);
                    if (UnityEngine.Physics.Raycast(ray, out UnityEngine.RaycastHit hit))
                    {
                        if (hit.collider != null)
                        {
                            actionPosition = new float3(hit.point.x, .5f, hit.point.z);
                        }
                    }

                    if (Actions.instance.actionPlaced)
                    {
                        EnablePanicModeJob enablePrePanicJob = new EnablePanicModeJob
                        {
                            actionPosition = actionPosition,
                            panicRadius = 10f,
                            CommandBuffer = m_EntityCommandBufferSystem.CreateCommandBuffer().ToConcurrent(), // Create the commandBuffer
                        };
                        jobHandle = enablePrePanicJob.Schedule(this, inputDeps);
                        m_EntityCommandBufferSystem.AddJobHandleForProducer(jobHandle); // Execute the commandBuffer commands when spawnJob is finished
                    }
                }

                PanicJob panicJob = new PanicJob
                {
                    actionPosition = actionPosition,
                    RandomGenerator = RandomGenerator,
                    exitsTranslations = exitsTranslations,
                    exitsExitComponents = exitsExitComponents,
                    quadrantMultiHashMap = QuadrantSystem.quadrantMultiHashMap
                };

                jobHandle = panicJob.Schedule(this, jobHandle);

                //WakeUpInactiveAgents wakeUpInactiveAgents = new WakeUpInactiveAgents
                //{
                //    agentAmount = agentQuery.CalculateEntityCount(),
                //    panicTagAmount = panicTagComponents.Length,
                //    CommandBuffer = m_EntityCommandBufferSystem.CreateCommandBuffer().ToConcurrent(),
                //    RandomGenerator = RandomGenerator,
                //    exitsTranslations = exitsTranslations,
                //    escapedTagAmount = escapedTagComponets.Length
                //};

                //jobHandle = wakeUpInactiveAgents.Schedule(this, jobHandle);
                //m_EntityCommandBufferSystem.AddJobHandleForProducer(jobHandle); // Execute the commandBuffer commands when spawnJob is finished
            }

            else if (Actions.instance.fallingTruss)
            {
                if (UnityEngine.Input.GetMouseButtonDown(0))
                {
                    // Small Explosions in Radial menu was selected
                    actionPosition = UnityEngine.Input.mousePosition;
                    UnityEngine.Ray ray = UnityEngine.Camera.main.ScreenPointToRay(actionPosition);
                    if (UnityEngine.Physics.Raycast(ray, out UnityEngine.RaycastHit hit))
                    {
                        if (hit.collider != null)
                        {
                            actionPosition = hit.collider.gameObject.transform.position; // The position of the falling truss Game Object
                            hit.collider.gameObject.GetComponent<InformationAnimation>().enabled = false;
                            hit.collider.gameObject.transform.GetChild(0).gameObject.SetActive(false);
                        }
                    }
                }

                if (Actions.instance.trussHasFallen) // THis bool is true, when the falling truss animation has completed with Unity events
                {
                    EnablePanicModeJob enablePrePanicJob = new EnablePanicModeJob
                    {
                        actionPosition = actionPosition,
                        panicRadius = 25f,
                        CommandBuffer = m_EntityCommandBufferSystem.CreateCommandBuffer().ToConcurrent(), // Create the commandBuffer
                    };
                    jobHandle = enablePrePanicJob.Schedule(this, inputDeps);
                    m_EntityCommandBufferSystem.AddJobHandleForProducer(jobHandle); // Execute the commandBuffer commands when spawnJob is finished
                }

                PanicJob panicJob = new PanicJob
                {
                    actionPosition = actionPosition,
                    RandomGenerator = RandomGenerator,
                    exitsTranslations = exitsTranslations,
                    exitsExitComponents = exitsExitComponents,
                    quadrantMultiHashMap = QuadrantSystem.quadrantMultiHashMap
                };

                jobHandle = panicJob.Schedule(this, jobHandle);

                //WakeUpInactiveAgents wakeUpInactiveAgents = new WakeUpInactiveAgents
                //{
                //    agentAmount = agentQuery.CalculateEntityCount(),
                //    panicTagAmount = panicTagComponents.Length,
                //    CommandBuffer = m_EntityCommandBufferSystem.CreateCommandBuffer().ToConcurrent(),
                //    RandomGenerator = RandomGenerator,
                //    exitsTranslations = exitsTranslations,
                //    escapedTagAmount = escapedTagComponets.Length
                //};

                //jobHandle = wakeUpInactiveAgents.Schedule(this, jobHandle);
                //m_EntityCommandBufferSystem.AddJobHandleForProducer(jobHandle); // Execute the commandBuffer commands when spawnJob is finished
            }

            // Only React on panic when panic action is enabled
            ReactOnPanicInsideQuadrantJob reactOnPanicInsideQuadrantJob = new ReactOnPanicInsideQuadrantJob
            {
                quadrantMultiHashMap = QuadrantSystem.quadrantMultiHashMap,
                exitsTranslations = exitsTranslations,
                exitsExitComponents = exitsExitComponents,
                actionPosition = actionPosition,
                RandomGenerator = RandomGenerator,
                CommandBuffer = m_EntityCommandBufferSystem.CreateCommandBuffer().ToConcurrent(), // Create the commandBuffer
            };

            jobHandle = reactOnPanicInsideQuadrantJob.Schedule(this, jobHandle);
            m_EntityCommandBufferSystem.AddJobHandleForProducer(jobHandle); // Execute the commandBuffer commands when spawnJob is finished
        }
        jobHandle.Complete(); // For writing on the multiHashMap (Quadrant System)

        return jobHandle;
    }
}
