using Unity.Entities;
using Unity.Jobs;
using Unity.Mathematics;
using Unity.Collections;
using Unity.Transforms;
using Unity.Burst;

[UpdateBefore(typeof(MovingSystem))]
[UpdateBefore(typeof(ManagerSystem))]
[UpdateBefore(typeof(JumpingSystem))]
[UpdateBefore(typeof(CalculateNewRandomPositionSystem))]
/// <summary>
/// System that reacts on panic spots, generated by mouse click.
/// </summary>
public class PanicSystem : JobComponentSystem
{
    //public static void CheckForClosestExit(float3 agentPosition/*, float3 collisionPosition, float panicRadius*/, ref AgentComponent agentComponent,
    //    NativeArray<Translation> exitsTranslations/*, Translation excludedTranslation = new Translation()*//*, float3 actionPosition*/, NativeArray<ExitComponent> exitsExitComponents)
    //{
    //    for (int i = 0; i < exitsTranslations.Length; i++)
    //    {
    //        if (math.distance(agentPosition, exitsTranslations[i].Value) < 20f)
    //        {
    //            if (!exitsExitComponents[i].overloaded)
    //            {
    //                //If Agent can see an exit, set this exit as target
    //                agentComponent.target = exitsTranslations[i].Value;
    //                agentComponent.hasTarget = true;
    //                agentComponent.foundFinalExitPoint = true;
    //                agentComponent.foundTemporaryNewRandomPosition = false;
    //            }
    //        }
    //    }
    //}

    //public static void AgentAmountCheck(NativeArray<Translation> exitsTranslations, ref AgentComponent agentComponent, float3 agentPosition,
    //    NativeMultiHashMap<int, QuadrantData> quadrantMultiHashMap)
    //{
    //    // Agent found exit and runs to it
    //    //if (exitsTranslations.Length > 1) // If there are more than 1 exits, decide which one contains less agents
    //    //{
    //    // In this period calculate the current amount of agents that are around this exit
    //    if (agentComponent.foundFinalExitPoint)
    //    {
    //        for (int i = 0; i < exitsTranslations.Length; i++)
    //        {
    //            if (agentComponent.target.Equals(exitsTranslations[i].Value))
    //            {
    //                if (QuadrantSystem.GetEntityCountInHashMap(quadrantMultiHashMap, QuadrantSystem.GetPositionHashMapKey(exitsTranslations[i].Value)) > 3)
    //                {
    //                    // If the Amunt is higher than 100, do
    //                    //CheckForClosestExit(agentPosition, ref agentComponent, exitsTranslations, excludedTranslation: exitsTranslations[i]);
    //                    agentComponent.agentStatus = AgentStatus.Running;
    //                    agentComponent.hasTarget = false;
    //                    agentComponent.testing = true;
    //                }
    //            }
    //        }
    //    }
    //    //}
    //}

    /// <summary>
    /// Every Agent in given radius gets the Panic AgentStatus
    /// </summary>
    [BurstCompile]
    public struct EnablePanicModeJob : IJobForEachWithEntity<AgentComponent, Translation>
    {
        [ReadOnly]
        public float panicRadius;

        [ReadOnly]
        public float3 actionPosition;

        public void Execute(Entity entity, int index, ref AgentComponent agentComponent, [ReadOnly] ref Translation translation)
        {
            if (math.distance(translation.Value, actionPosition) <= panicRadius)
            {
                // Agent close to the action position
                // Enable Pre Panic Mode
                agentComponent.agentStatus = AgentStatus.Running;
            }
        }
    }

    [BurstCompile]
    public struct PanicJob : IJobForEachWithEntity<Translation, AgentComponent, BorderComponent>
    {
        [ReadOnly]
        public NativeMultiHashMap<int, QuadrantData> quadrantMultiHashMap;

        [ReadOnly] public NativeArray<Translation> exitsTranslations;
        [ReadOnly] public NativeArray<ExitComponent> exitsExitComponents;

        public float3 actionPosition; // The spot where the action arised
        [NativeDisableParallelForRestriction]
        [DeallocateOnJobCompletion]
        public NativeArray<Random> RandomGenerator;

        [Unity.Collections.LowLevel.Unsafe.NativeSetThreadIndex]
        private int threadIndex;

        public void Execute(Entity entity, int index, [ReadOnly] ref Translation translation, ref AgentComponent agentComponent, [ReadOnly] ref BorderComponent borderComponent)
        {
            var randomGenerator = RandomGenerator[threadIndex - 1];

            RandomGenerator[threadIndex - 1] = randomGenerator; //This is necessary to update the state of the element inside the array.

            var rnd = RandomGenerator[threadIndex - 1];

            // Generate new random position on map
            if (agentComponent.agentStatus == AgentStatus.Running && !agentComponent.hasTarget /*&& !agentComponent.exitPointReached*/)
            {
                // Generate random position on map
                // Set target for enabling Running Job in Running System
                float3 randomGeneratedPanicPosition = float3.zero;
                float3 tempRandomPosition = float3.zero;
                while (randomGeneratedPanicPosition.Equals(float3.zero))
                {
                    tempRandomPosition = new float3(
                        rnd.NextFloat(borderComponent.backRight.x, borderComponent.backLeft.x),
                        .5f,
                        rnd.NextFloat(borderComponent.frontLeft.z, borderComponent.backLeft.z));

                    if (CalculateNewRandomPositionSystem.IsInsideFestivalArea(ref borderComponent, tempRandomPosition))
                    {
                        // If tempRandomPosition is inside the festival Area, set this random Position and trigger the Running Job in the RunningSystem
                        randomGeneratedPanicPosition = tempRandomPosition;

                        agentComponent.target = randomGeneratedPanicPosition;
                        agentComponent.hasTarget = true;
                        agentComponent.foundTemporaryNewRandomPosition = true;
                    }
                }
            }
            // Calculate nearest exit. Look on the exit and check if its overloaded. Only set this exit as target when its not overloaed
            else if (agentComponent.agentStatus == AgentStatus.Running && agentComponent.hasTarget && agentComponent.foundTemporaryNewRandomPosition && !agentComponent.foundFinalExitPoint && !agentComponent.marked)
            {
                for (int i = 0; i < exitsTranslations.Length; i++)
                {
                    if (math.distance(translation.Value, exitsTranslations[i].Value) < 20f) // Agents in der Nähe von 20 meiden einen exit der überladen ist
                    {
                        if (!exitsExitComponents[i].overloaded /*&& !agentComponent.marked*/)
                        {
                            //If Agent can see an exit, set this exit as target
                            agentComponent.target = exitsTranslations[i].Value;
                            agentComponent.hasTarget = true;
                            agentComponent.foundFinalExitPoint = true;
                            agentComponent.foundTemporaryNewRandomPosition = false;
                        }
                        else
                        {
                            agentComponent.hasTarget = false;
                        }
                    }
                    else if (math.distance(translation.Value, exitsTranslations[i].Value) >= 20.0f)
                    {
                        // Every Agent with distance greater than 40 will look on the overloaded bool on this exit
                        float dice = rnd.NextFloat(1000.0f);

                        if (dice <= agentComponent.discoverProbability)
                        {
                            agentComponent.target = exitsTranslations[i].Value;
                            agentComponent.hasTarget = true;
                            agentComponent.foundFinalExitPoint = true;
                            agentComponent.foundTemporaryNewRandomPosition = false;

                            agentComponent.discoverProbability += 5.5f; // Increase the probability for running to an exit where a lot of agents are 

                        }
                        else
                        {
                            agentComponent.hasTarget = false;
                        }
                    }
                }
            }
            else if (agentComponent.agentStatus != AgentStatus.Running)
            {
                // For those which are standing in a corner of the festival area
                for (int i = 0; i < exitsExitComponents.Length; i++)
                {
                    if (exitsExitComponents[i].overloaded)
                    {
                        agentComponent.agentStatus = AgentStatus.Running;
                        //agentComponent.target = exitsTranslations[i].Value;
                        //agentComponent.hasTarget = true;
                        //agentComponent.foundFinalExitPoint = true;
                    }
                }
            }
            if (agentComponent.foundFinalExitPoint && agentComponent.hasTarget)
            {
                // Agent runs to an exit
                for (int i = 0; i < exitsTranslations.Length; i++)
                {
                    if (agentComponent.target.Equals(exitsTranslations[i].Value))
                    {
                        if (exitsExitComponents[i].overloaded)
                        {
                            // Agents notices on the way to the exit that this exis is overloaded now, randomly decide if it shall keep this exit or to choose another one

                            float dice = rnd.NextFloat(1000f);

                            if (dice <= agentComponent.fleeProbability)
                            {
                                agentComponent.hasTarget = false;
                                agentComponent.foundFinalExitPoint = false;
                                agentComponent.marked = true;

                                if (agentComponent.fleeProbability - 5.5f < 0.0f)
                                {
                                    agentComponent.fleeProbability = 22.22f;
                                }
                                else
                                {
                                    agentComponent.fleeProbability -= 5.5f;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /// <summary>
    /// Job that handles the reaction of an agent when beeing in near of an agent that has panic and is in running mode.
    /// </summary>
    [BurstCompile]
    public struct ReactOnPanicInsideQuadrantJob : IJobForEachWithEntity<Translation, AgentComponent, QuadrantEntity>
    {
        [ReadOnly]
        public NativeMultiHashMap<int, QuadrantData> quadrantMultiHashMap;

        [ReadOnly]
        public NativeArray<Translation> exitsTranslations;

        [ReadOnly]
        public NativeArray<ExitComponent> exitsExitComponents;

        [ReadOnly]
        public float3 actionPosition; // position where panic appears

        public void Execute(Entity entity, int index, [ReadOnly] ref Translation translation, ref AgentComponent agentComponent, ref QuadrantEntity quadrantEntity)
        {
            int hashMapKey = QuadrantSystem.GetPositionHashMapKey(translation.Value); // Calculate the correct quadrant for this agent
            CalculatePanicReaction(hashMapKey, ref translation, ref agentComponent); // This quadrant itself (mid)
            CalculatePanicReaction(hashMapKey + 1, ref translation, ref agentComponent); // Right quadrant
            CalculatePanicReaction(hashMapKey - 1, ref translation, ref agentComponent); // Left quadrant
            CalculatePanicReaction(hashMapKey + QuadrantSystem.quadrantYMultiplier, ref translation, ref agentComponent); // Above quadrant
            CalculatePanicReaction(hashMapKey - QuadrantSystem.quadrantYMultiplier, ref translation, ref agentComponent); // Below quadrant

            CalculatePanicReaction(hashMapKey + 1 + QuadrantSystem.quadrantYMultiplier, ref translation, ref agentComponent); // Corner Top Right
            CalculatePanicReaction(hashMapKey - 1 + QuadrantSystem.quadrantYMultiplier, ref translation, ref agentComponent); // Corner Top Left
            CalculatePanicReaction(hashMapKey + 1 - QuadrantSystem.quadrantYMultiplier, ref translation, ref agentComponent); // Corner Bottom Right
            CalculatePanicReaction(hashMapKey - 1 - QuadrantSystem.quadrantYMultiplier, ref translation, ref agentComponent); // Corner Bottom Left

        }

        private void CalculatePanicReaction(int hashMapKey, ref Translation translation, ref AgentComponent agentComponent)
        {
            // Cycling through all entitys/agents inside this quadrant
            // Check if you as an agent sees an agent with panic running to you (5f)
            // You see that he has panic so you will have panic to.
            // You adept his target because you want to run to the same place
            // You start running
            QuadrantData quadrantData;
            NativeMultiHashMapIterator<int> nativeMultiHashMapIterator;
            if (quadrantMultiHashMap.TryGetFirstValue(hashMapKey, out quadrantData, out nativeMultiHashMapIterator))
            {
                do
                {
                    if (math.distance(translation.Value, quadrantData.position) < 20
                        && quadrantData.agentComponent.agentStatus == AgentStatus.Running
                        && !quadrantData.agentComponent.exitPointReached // prevent stopping at exit
                        && !agentComponent.exitPointReached) // prevent stopping at exit
                    {
                        agentComponent.agentStatus = AgentStatus.Running;
                    }

                    if (math.distance(translation.Value, quadrantData.position) < 30
                        && quadrantData.agentComponent.foundFinalExitPoint
                        && !quadrantData.agentComponent.exitPointReached
                        && !agentComponent.exitPointReached
                        && !agentComponent.marked)
                    {
                        agentComponent.target = quadrantData.agentComponent.target;
                        agentComponent.foundFinalExitPoint = true;
                        agentComponent.hasTarget = true;
                    }
                } while (quadrantMultiHashMap.TryGetNextValue(out quadrantData, ref nativeMultiHashMapIterator));
            }
        }
    }


    float3 actionPosition;
    int actionMode;
    float panicRadius;
    Random Rnd = new Random(1);
    NativeArray<Random> RandomGenerator;
    /// <summary>
    /// Runs on main thread, 1 times per frame
    /// </summary>
    /// <param name="inputDeps"></param>
    /// <returns></returns>
    protected override JobHandle OnUpdate(JobHandle inputDeps)
    {
        JobHandle jobHandle = new JobHandle();
        RandomGenerator = new NativeArray<Random>(System.Environment.ProcessorCount, Allocator.TempJob);

        for (int i = 0; i < RandomGenerator.Length; i++)
        {
            RandomGenerator[i] = new Random((uint)Rnd.NextInt());
        }

        if (Actions.instance.actionEnabled) // If action is enabled, get all exits and calculate the closest position
        {
            EntityQuery exitQuery = GetEntityQuery(typeof(ExitComponent), ComponentType.ReadOnly<Translation>());

            NativeArray<Translation> exitsTranslations = exitQuery.ToComponentDataArray<Translation>(Allocator.TempJob);
            NativeArray<ExitComponent> exitsExitComponents = exitQuery.ToComponentDataArray<ExitComponent>(Allocator.TempJob);

            if (Actions.instance.smallGroundExplosion)
            {
                actionMode = 1;
                if (UnityEngine.Input.GetMouseButtonDown(0))
                {
                    // Small Explosions in Radial menu was selected
                    actionPosition = UnityEngine.Input.mousePosition;
                    UnityEngine.Ray ray = UnityEngine.Camera.main.ScreenPointToRay(actionPosition);
                    if (UnityEngine.Physics.Raycast(ray, out UnityEngine.RaycastHit hit))
                    {
                        if (hit.collider != null)
                        {
                            actionPosition = new float3(hit.point.x, .5f, hit.point.z);
                        }
                    }

                    EnablePanicModeJob enablePrePanicJob = new EnablePanicModeJob
                    {
                        actionPosition = actionPosition,
                        panicRadius = 5f // TODO set
                    };
                    jobHandle = enablePrePanicJob.Schedule(this, inputDeps);
                }
                //for (int i = 0; i < exitsTranslations.Length; i++)
                //{
                //    UnityEngine.Debug.Log(QuadrantSystem.GetEntityCountInHashMap(QuadrantSystem.quadrantMultiHashMap, QuadrantSystem.GetPositionHashMapKey(exitsTranslations[i].Value)));
                //}

                PanicJob panicJob = new PanicJob
                {
                    actionPosition = actionPosition,
                    RandomGenerator = RandomGenerator,
                    exitsTranslations = exitsTranslations,
                    exitsExitComponents = exitsExitComponents,
                    quadrantMultiHashMap = QuadrantSystem.quadrantMultiHashMap
                };
                jobHandle = panicJob.Schedule(this, jobHandle);
            }

            // Only React on panic when panic action is enabled
            ReactOnPanicInsideQuadrantJob reactOnPanicInsideQuadrantJob = new ReactOnPanicInsideQuadrantJob
            {
                quadrantMultiHashMap = QuadrantSystem.quadrantMultiHashMap,
                exitsTranslations = exitsTranslations,
                exitsExitComponents = exitsExitComponents,
                actionPosition = actionPosition
            };

            jobHandle = reactOnPanicInsideQuadrantJob.Schedule(this, jobHandle);
        }
        jobHandle.Complete(); // For writing on the multiHashMap (Quadrant System)
        return jobHandle;
    }
}
