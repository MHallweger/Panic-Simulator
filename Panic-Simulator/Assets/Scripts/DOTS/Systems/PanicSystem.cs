using Unity.Entities;
using Unity.Jobs;
using Unity.Mathematics;
using Unity.Collections;
using Unity.Transforms;
using Unity.Burst;

[UpdateBefore(typeof(MovingSystem))]
[UpdateBefore(typeof(ManagerSystem))]
[UpdateBefore(typeof(JumpingSystem))]
[UpdateBefore(typeof(CalculateNewRandomPositionSystem))]
/// <summary>
/// System that reacts on panic spots, generated by mouse click.
/// </summary>
public class PanicSystem : JobComponentSystem
{
    public static void CalculateNearestExitPoint(float3 agentPosition/*, float3 collisionPosition, float panicRadius*/, ref AgentComponent agentComponent,
        NativeArray<Translation> exitsTranslations, float3 actionPosition)
    {
        //var test = math.distance(agentPosition, collisionPosition);
        //if (test <= panicRadius)
        //{
        if (!agentComponent.exitPointReached)
        {
            float3 closestExitTarget = float3.zero;

            // Calculate optimal exit dependencies
            if (agentPosition.x <= actionPosition.x && agentPosition.z >= actionPosition.z)
            {
                // Agent is in the top left corner with actionPosition as center
                // Only use exits in the top left corner

                for (int i = 0; i < exitsTranslations.Length; i++)
                {
                    if (exitsTranslations[i].Value.x <= actionPosition.x && exitsTranslations[i].Value.z >= actionPosition.z) // Just use this exitTranslation when it's in the top left corner with actionPosition as center 
                    {
                        // Action is close to exit, do not use this exit
                        if (closestExitTarget.Equals(float3.zero))
                        {
                            // No target
                            closestExitTarget = exitsTranslations[i].Value;
                        }
                        else
                        {
                            if (math.distance(agentPosition, exitsTranslations[i].Value) < math.distance(agentPosition, closestExitTarget))
                            {
                                closestExitTarget = exitsTranslations[i].Value;
                            }
                        }
                    }
                }
            }
            else if (agentPosition.x >= actionPosition.x && agentPosition.z >= actionPosition.z)
            {
                // Agent is in the top right corner with actionPosition as center
                // Only use exits in the top right corner

                for (int i = 0; i < exitsTranslations.Length; i++)
                {
                    if (exitsTranslations[i].Value.x >= actionPosition.x && exitsTranslations[i].Value.z >= actionPosition.z) // Just use this exitTranslation when it's in the top right corner with actionPosition as center 
                    {
                        // Action is close to exit, do not use this exit
                        if (closestExitTarget.Equals(float3.zero))
                        {
                            // No target
                            closestExitTarget = exitsTranslations[i].Value;
                        }
                        else
                        {
                            if (math.distance(agentPosition, exitsTranslations[i].Value) < math.distance(agentPosition, closestExitTarget))
                            {
                                closestExitTarget = exitsTranslations[i].Value;
                            }
                        }
                    }
                }
            }
            else if (agentPosition.x <= actionPosition.x && agentPosition.z <= actionPosition.z)
            {
                // Agent is in the bottom left corner with actionPosition as center
                // Only use exits in the bottom left corner

                for (int i = 0; i < exitsTranslations.Length; i++)
                {
                    if (exitsTranslations[i].Value.x <= actionPosition.x /*&& exitsTranslations[i].Value.z <= actionPosition.z*/) // Just use this exitTranslation when it's in the bottom left corner with actionPosition as center 
                    {
                        // Action is close to exit, do not use this exit
                        if (closestExitTarget.Equals(float3.zero))
                        {
                            // No target
                            closestExitTarget = exitsTranslations[i].Value;
                        }
                        else
                        {
                            if (math.distance(agentPosition, exitsTranslations[i].Value) < math.distance(agentPosition, closestExitTarget))
                            {
                                closestExitTarget = exitsTranslations[i].Value;
                            }
                        }
                    }
                }
            }
            else if (agentPosition.x >= actionPosition.x && agentPosition.z <= actionPosition.z)
            {
                // Agent is in the bottom right corner with actionPosition as center
                // Only use exits in the bottom right corner

                for (int i = 0; i < exitsTranslations.Length; i++)
                {
                    if (exitsTranslations[i].Value.x >= actionPosition.x /*&& exitsTranslations[i].Value.z <= actionPosition.z*/) // Just use this exitTranslation when it's in the bottom right corner with actionPosition as center 
                    {
                        // Action is close to exit, do not use this exit
                        if (closestExitTarget.Equals(float3.zero))
                        {
                            // No target
                            closestExitTarget = exitsTranslations[i].Value;
                        }
                        else
                        {
                            if (math.distance(agentPosition, exitsTranslations[i].Value) < math.distance(agentPosition, closestExitTarget))
                            {
                                closestExitTarget = exitsTranslations[i].Value;
                            }
                        }
                    }
                }
            }
            agentComponent.target = closestExitTarget;
            agentComponent.agentStatus = AgentStatus.Running; //???
            agentComponent.hasTarget = true;
            //agentComponent.foundFinalExitPoint = true;
        }
        //}
    }

    /// <summary>
    /// Every Agent in given radius gets the Panic AgentStatus
    /// </summary>
    [BurstCompile]
    public struct EnablePanicModeJob : IJobForEachWithEntity<AgentComponent, Translation>
    {
        [ReadOnly]
        public float panicRadius;

        [ReadOnly]
        public float3 actionPosition;

        public void Execute(Entity entity, int index, ref AgentComponent agentComponent, [ReadOnly] ref Translation translation)
        {
            if (math.distance(translation.Value, actionPosition) <= panicRadius)
            {
                // Agent close to the action position
                // Enable Pre Panic Mode
                agentComponent.agentStatus = AgentStatus.Running;
            }
        }
    }

    [BurstCompile]
    public struct PanicJob : IJobForEachWithEntity<Translation, AgentComponent, BorderComponent>
    {
        [ReadOnly] public NativeArray<Translation> exitsTranslations;

        public float3 actionPosition; // The spot where the action arised
        [NativeDisableParallelForRestriction]
        [DeallocateOnJobCompletion]
        public NativeArray<Random> RandomGenerator;

        [Unity.Collections.LowLevel.Unsafe.NativeSetThreadIndex]
        private int threadIndex;

        public void Execute(Entity entity, int index, [ReadOnly] ref Translation translation, ref AgentComponent agentComponent, [ReadOnly] ref BorderComponent borderComponent)
        {
            var randomGenerator = RandomGenerator[threadIndex - 1];

            RandomGenerator[threadIndex - 1] = randomGenerator; //This is necessary to update the state of the element inside the array.

            var rnd = RandomGenerator[threadIndex - 1];

            if (agentComponent.agentStatus == AgentStatus.Running && !agentComponent.hasTarget)
            {
                // Generate random position on map
                // Set target for enabling Running Job in Running System
                float3 randomGeneratedPanicPosition = float3.zero;
                float3 tempRandomPosition = float3.zero;
                while (randomGeneratedPanicPosition.Equals(float3.zero))
                {
                    tempRandomPosition = new float3(
                        rnd.NextFloat(borderComponent.backRight.x, borderComponent.backLeft.x),
                        .5f,
                        rnd.NextFloat(borderComponent.frontLeft.z, borderComponent.backLeft.z));

                    if (CalculateNewRandomPositionSystem.IsInsideFestivalArea(ref borderComponent, tempRandomPosition))
                    {
                        // If tempRandomPosition is inside the festival Area, set this random Position and trigger the Running Job in the RunningSystem
                        randomGeneratedPanicPosition = tempRandomPosition;

                        agentComponent.target = randomGeneratedPanicPosition;
                        agentComponent.hasTarget = true;
                    }
                }
            }
        }
    }

    /// <summary>
    /// Job that handles the reaction of an agent when beeing in near of an agent that has panic and is in running mode.
    /// </summary>
    [BurstCompile]
    public struct ReactOnPanicInsideQuadrantJob : IJobForEachWithEntity<Translation, AgentComponent>
    {
        [ReadOnly]
        public NativeMultiHashMap<int, QuadrantData> quadrantMultiHashMap;

        [ReadOnly]
        public NativeArray<Translation> exitsTranslations;

        [ReadOnly]
        public float3 actionPosition; // position where panic appears

        public void Execute(Entity entity, int index, [ReadOnly] ref Translation translation, ref AgentComponent agentComponent)
        {
            int hashMapKey = QuadrantSystem.GetPositionHashMapKey(translation.Value); // Calculate the correct quadrant for this agent
            CalculatePanicReaction(hashMapKey, ref translation, ref agentComponent); // This quadrant itself (mid)
            CalculatePanicReaction(hashMapKey + 1, ref translation, ref agentComponent); // Right quadrant
            CalculatePanicReaction(hashMapKey - 1, ref translation, ref agentComponent); // Left quadrant
            CalculatePanicReaction(hashMapKey + QuadrantSystem.quadrantYMultiplier, ref translation, ref agentComponent); // Above quadrant
            CalculatePanicReaction(hashMapKey - QuadrantSystem.quadrantYMultiplier, ref translation, ref agentComponent); // Below quadrant

            CalculatePanicReaction(hashMapKey + 1 + QuadrantSystem.quadrantYMultiplier, ref translation, ref agentComponent); // Corner Top Right
            CalculatePanicReaction(hashMapKey - 1 + QuadrantSystem.quadrantYMultiplier, ref translation, ref agentComponent); // Corner Top Left
            CalculatePanicReaction(hashMapKey + 1 - QuadrantSystem.quadrantYMultiplier, ref translation, ref agentComponent); // Corner Bottom Right
            CalculatePanicReaction(hashMapKey - 1 - QuadrantSystem.quadrantYMultiplier, ref translation, ref agentComponent); // Corner Bottom Left

        }

        private void CalculatePanicReaction(int hashMapKey, ref Translation translation, ref AgentComponent agentComponent)
        {
            // Cycling through all entitys/agents inside this quadrant
            // Check if you as an agent sees an agent with panic running to you (5f)
            // You see that he has panic so you will have panic to.
            // You adept his target because you want to run to the same place
            // You start running
            QuadrantData quadrantData;
            NativeMultiHashMapIterator<int> nativeMultiHashMapIterator;
            if (quadrantMultiHashMap.TryGetFirstValue(hashMapKey, out quadrantData, out nativeMultiHashMapIterator))
            {
                do
                {
                    if (math.distance(translation.Value, quadrantData.position) <= 20.0f
                    && !quadrantData.agentComponent.exitPointReached
                    && !agentComponent.exitPointReached)
                    {
                        if (quadrantData.agentComponent.agentStatus == AgentStatus.Running)
                        {
                            agentComponent.agentStatus = AgentStatus.Running;
                        }
                    }
                } while (quadrantMultiHashMap.TryGetNextValue(out quadrantData, ref nativeMultiHashMapIterator));
            }
        }
    }

    float3 actionPosition;
    int actionMode;
    float panicRadius;
    Random Rnd = new Random(1);
    NativeArray<Random> RandomGenerator;
    /// <summary>
    /// Runs on main thread, 1 times per frame
    /// </summary>
    /// <param name="inputDeps"></param>
    /// <returns></returns>
    protected override JobHandle OnUpdate(JobHandle inputDeps)
    {
        JobHandle jobHandle = new JobHandle();
        RandomGenerator = new NativeArray<Random>(System.Environment.ProcessorCount, Allocator.TempJob);

        for (int i = 0; i < RandomGenerator.Length; i++)
        {
            RandomGenerator[i] = new Random((uint)Rnd.NextInt());
        }

        if (Actions.instance.actionEnabled) // If action is enabled, get all exits and calculate the closest position
        {
            EntityQuery exitQuery = GetEntityQuery(typeof(ExitComponent), ComponentType.ReadOnly<Translation>());

            NativeArray<Translation> exitsTranslations = exitQuery.ToComponentDataArray<Translation>(Allocator.TempJob);

            if (Actions.instance.smallGroundExplosion)
            {
                actionMode = 1;
                if (UnityEngine.Input.GetMouseButtonDown(0))
                {
                    // Small Explosions in Radial menu was selected
                    actionPosition = UnityEngine.Input.mousePosition;
                    UnityEngine.Ray ray = UnityEngine.Camera.main.ScreenPointToRay(actionPosition);
                    if (UnityEngine.Physics.Raycast(ray, out UnityEngine.RaycastHit hit))
                    {
                        if (hit.collider != null)
                        {
                            actionPosition = new float3(hit.point.x, .5f, hit.point.z);
                        }
                    }

                    EnablePanicModeJob enablePrePanicJob = new EnablePanicModeJob
                    {
                        actionPosition = actionPosition,
                        panicRadius = 5f // TODO set
                    };
                    jobHandle = enablePrePanicJob.Schedule(this, inputDeps);
                }

                PanicJob panicJob = new PanicJob
                {
                    actionPosition = actionPosition,
                    RandomGenerator = RandomGenerator,
                    exitsTranslations = exitsTranslations
                };
                jobHandle = panicJob.Schedule(this, jobHandle);
            }

            // Only React on panic when panic action is enabled
            ReactOnPanicInsideQuadrantJob reactOnPanicInsideQuadrantJob = new ReactOnPanicInsideQuadrantJob
            {
                quadrantMultiHashMap = QuadrantSystem.quadrantMultiHashMap,
                exitsTranslations = exitsTranslations,
                actionPosition = actionPosition
            };

            jobHandle = reactOnPanicInsideQuadrantJob.Schedule(this, jobHandle);
        }
        return jobHandle;
    }
}
